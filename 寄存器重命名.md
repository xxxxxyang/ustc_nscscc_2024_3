# 寄存器重命名

+ 背景问题——数据相关

  + WAW
  + RAW
  + WAR

  其中WAW与WAR是假相关。二者事实上无数据依赖性，通关使用不同寄存器名字来解决。但仍有问题：

  + 寄存器个数不够，使得无空闲寄存器可分配
  
  为解决该问题，引入重命名技术：让CPU中实际的寄存器比架构定义的个数更多，并在运行时动态地将逻辑寄存器映射到物理寄存器
  
  + 逻辑寄存器（ARF）
  + 物理寄存器（PRF）
  + 重命名映射表（RAT）

+ 重命名的方法

  + 基本考虑
  	
  	1. 什么时候占用一个物理寄存器？这个物理寄存器来自哪里？
  	
  	2. 什么时候释放一个物理寄存器？这个物理寄存器去往何处？
  	
  	3. 分支预测失败时的处理
  	
  	4. 发生异常的处理
  	
  	下面每种方法下1~4的编号后为对应问题的回答
  	
  + 三种实现方法

    + 使用ROB来实现寄存器重命名
  
      + 将物理寄存器堆放在ROB中，每一条指令对应表项的data域作为物理寄存器
  
    
      1. 当一条指令写入ROB表项时，该表项在ROB的编号作为其目的寄存器对应的物理寄存器。
    
      2. 当指令从ROB退休时，该物理寄存器中存的值转存到ARF，并将位置变动信息更新到重命名映射表
    
      3. 4. ROB中存的是推测值，对物理寄存器堆的处理不需要特殊，与对ROB处理相同即可
    
      缺点：无目的寄存器的指令造成空间浪费，利用率低；让ROB与ARF的读端口变多，对芯片面积与延迟有影响
    
    + 将逻辑寄存器扩展来实现寄存器重命名
    
      + 由于使用ROB来实现利用率低，不妨考虑用一个单独实现的PRF代替前面ROB表项中的data域，操作与前面方法基本相同，不过只有有目的寄存器的指令才能占用PRF
    
      1. 当一条有目的寄存器的指令重命名时，占用PRF中的一个空间作为其目的寄存器对应的物理寄存器。若PRF已满，则把重命名之前的流水线暂停
      2. 当指令从ROB退休时，该物理寄存器中存的值转存到ARF，并将位置变动信息更新到重命名映射表中
      3. 4. PRF可视为ROB的一部分，对其处理不需要特殊，与对ROB处理相同即可
    
    + 用统一的物理寄存器来实现寄存器重命名
    
      + 前两种方法中数据会从PRF搬到ARF，为了便于读，将ARF与PRF统一为一个寄存器堆
    
      1. 当一条有目的寄存器的指令重命名时，通过查重命名表，给出源寄存器对应的物理寄存器，同时给目的寄存器分配一个物理寄存器
      2. 当物理寄存器不再被后面指令使用时，将该物理寄存器变空闲，实际实现时，当下个写同一ARF的指令提交以后，该物理寄存器空闲
  
  + 重命名映射表
  
    + 基于SRAM
  
      + ARF -> PRF
      + freelist
      + 保存旧的映射用于恢复
  
      + 更快，功耗更小
  
    + 基于CAM
  
      + PRF -> ARF
      + freelist
      + valid位
      + CAM+RAM ？
      + 分支预测失败的恢复
  
      + Checkpoint电路复杂度与面积小
  
+ 超标量处理器的重命名

  + 过程
    + RAT：每并行一条指令需要RAT3读口1写口
    + 同一周期处理的4条指令有RAW，WAR（Dismissed），WAW
  + 解决RAW
  
  + 解决WAW
    + 对RAT进行检查
    + 对ROB进行检查
  
  + RAT用读优先
  + 存在没有目的寄存器的指令时的处理

+ 寄存器重命名的恢复——RAT的恢复

  + 使用Checkpoint（GC）
    + Random Access
    + ~~串行访问~~
  + 使用WALK
  + 使用Architecture State

+ 分发
  + 经过重命名后的指令被写到流水线的很多的缓存中
    + 发射队列（顺序）
    + 发射队列（乱序）
    + ROB
